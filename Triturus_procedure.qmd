---
title: "Affine Newt Alignment"
subtitle: "Newt affine alignment for newt affine aligners."
format:
  html:
    toc: true
    html-math-method: katex
    code-fold: false
    embed-resources: true
knitr:
  opts_chunk:
    echo: true
---


# Procedure

- load image
- exposure normalization
- find features (blobs? yellow?)
- rotate rostro-caudal axis
- crop
- save


# pyenv

```{sh setup-virtual-environment}
#| eval: false
python -m venv newts
```

```{sh python-packages}
#| eval: false
source newts/bin/activate.fish
pip install --upgrade pip

# pip install --upgrade numpy scipy pandas matplotlib scikit-image pygobject
# pip freeze > requirements.txt
pip install --upgrade -r requirements.txt
```

# start python

```{sh start-python}
#| eval: false
source newts/bin/activate.fish
python

```

```{python libraries}
import numpy as np
import scipy.ndimage as ndi
import scipy.signal as sig
import skimage.io as skiio
import skimage.color as skicol
import skimage.filters as skifilt
import skimage.morphology as skimorph
import skimage.measure as skimeas
import skimage.segmentation as skiseg
import matplotlib as mpl
import matplotlib.pyplot as plt

# mpl.use("TkAgg")
mpl.use("gtk4agg")

```

# helper function

```{python show-function}

def show(img, ax = None, **kwargs):

    if ax is None:
        fig, ax = plt.subplots(1, 1)

    if len(img.shape) == 3:
        ax.imshow(img, origin = "upper")
    else:
        ax.imshow(img, origin = "upper", cmap = "gray")

    ax.set_axis_off()

    title = kwargs.get("title", None)
    if title is not None:
        ax.set_title(title)

```


# load image

## raw

```{python load-image}
#image_file = "Triturus cristatus_female_4_2025-03-17_106_IMG_9269.JPG"
image_file = "Triturus cristatus_male_4_2025-03-18_161_IMG_9396.JPG"
img = skiio.imread(image_file)

show(img, title = "raw photo")
plt.show()
```


## three channels

note:

- yellow gets best contrast on "red" channel
- on the red channel, the red marker text vanishes :)
- on the blue channel, the whole animal is black!
- petri dish is overexposed on all channels for this image


```{python split-channels}

fig, axarr = plt.subplots(1, 3)

for i in range(3):
    show(img[:,:,i], ax = axarr[i], title = "RGB"[i])

plt.show()
```


## hsv

There are other [color](https://scikit-image.org/docs/stable/api/skimage.color.html) 
spaces, [e.g.](https://en.wikipedia.org/wiki/HSL_and_HSV)
hsv (<https://stackoverflow.com/a/54632519>)

```{python convert-hsv}
img_hsv = skicol.rgb2hsv(img)

fig, axarr = plt.subplots(1, 3)

for i in range(3):
    show(img_hsv[:,:,i], ax = axarr[i], title = "HSV"[i])

plt.show()
```




## yuv

luma/chroma [yuv](https://en.wikipedia.org/wiki/Y%E2%80%B2UV)


```{python convert-yuv}
img_yuv = skicol.rgb2yuv(img)

fig, axarr = plt.subplots(1, 3)

for i in range(3):
    show(img_yuv[:,:,i], ax = axarr[i])

plt.show()
```

## inverting!

Remember that you can invert the channels!
When looking for good channels to separate the newt from the background, look for dark *and* light.

```{python invert-hsv}

show(1.-img_hsv[:,:,2], title = "inverted V")
plt.show()
```

## improvement

We can use the fact that the dish is the biggest object in the picture:

- find the dish
- fill "holes"
- blank region outside the dish
- then find the newt again.


```{python close-petri-dish}

mod = img_hsv[:,:,2] # the "V" channel

# plt.hist(mod.ravel(), bins = 256); plt.show()

# apply threshold
# thresh = (1.+skifilt.threshold_otsu(mod))/2 # good old otsu is just too low :)
thresh = 0.98 #np.quantile(mod, [0.8])[0] # Otsu is just a simple histogram method...

bw = skimorph.closing(mod > thresh,
                      skimorph.footprint_rectangle((5, 5)))
# plt.imshow(bw); plt.show()

# bw = skimorph.area_opening(bw, area_threshold = 8)

# label image regions
label_image = skimorph.label(bw)

biggest = np.argmax([region.area for region in skimeas.regionprops(label_image)])
# plt.imshow(label_image == int(1+biggest)); plt.show()
mask = skimorph.convex_hull_image(label_image == int(1+biggest))
# to make the background transparent, pass the value of `bg_label`,
# and leave `bg_color` as `None` and `kind` as `overlay`
image_label_overlay = skicol.label2rgb(mask, image=img, bg_label=0)



show(image_label_overlay, title = "petri dish mask")
plt.show()
```


```{python mask-image}
img_masked = img_hsv[:, :, 2]
img_masked[np.logical_not(mask)] = 1.

show(img_masked, title = "petri dish only")
plt.show()
```


# Image Differentials

First of all, we can subtract channels:

```{python rb-diff}
diff_img = img[:,:,0]-img[:,:,2]

show(diff_img, title = "red minus blue")
plt.show()
```

... but the problem is the background.
It might work better with some blur, though (not tested).


Then, there are spatial differentials:

```{python edge-sobel}
img_edge_sobel = skifilt.sobel(img)

fig, axarr = plt.subplots(1, 2)

show(img_edge_sobel, ax = axarr[0], title = "sobel edge filter")
show(img_edge_sobel[:, :, 2], ax = axarr[1], title = "blue channel of the sobel")

plt.show()
```


## not pursued

the image could be scaled down
`image_rescaled = rescale(image, 0.25, anti_aliasing=False)`

Or better, apply some gaussian blur to smear out the non-newt contrast edges of the petri dish.




# Segmentation

... is just a name for the process of finding things in the image, 
separating "the relevant" from "the irrelevant" (no offence to petri dish manufacturers).

- <https://scikit-image.org/docs/stable/auto_examples/segmentation/plot_label.html#sphx-glr-auto-examples-segmentation-plot-label-py>


```{python labels}

mod = 1. - img_masked

# apply threshold
thresh = skifilt.threshold_otsu(mod) # good old otsu :)
bw = skimorph.closing(mod > thresh,
                      skimorph.footprint_rectangle((17, 17)))

# label image regions
label_image = skimorph.label(bw)
biggest = np.argmax([region.area for region in skimeas.regionprops(label_image)])
newt_mask = label_image == int(1+biggest)

image_label_overlay = skicol.label2rgb(newt_mask, image=img, bg_label=0)

show(image_label_overlay, title = "lonely newt")
plt.show()
```


... or immediately turn to the fancy stuff?
- <https://scikit-image.org/docs/stable/auto_examples/segmentation/plot_morphsnakes.html#sphx-glr-auto-examples-segmentation-plot-morphsnakes-py>

```{python snakes-for-newts}
#| eval: false

mod = 1. - img_masked # the inverted "V" channel

init_ls = skiseg.checkerboard_level_set(mod.shape, 8)

# fig, ax = plt.subplots(1, 1)
# ax.imshow(init_ls)
# ax.set_axis_off()
# ax.set_title("init")
# plt.show()


ls = skiseg.morphological_chan_vese(
    mod,
    num_iter=16,
    init_level_set=init_ls,
    smoothing=11
)


show(ls, title = "morphological snakes")
plt.show()
```

Oh, wow, that takes a bit, but the result is mildly promising.


Anyways, I will stick with the "simple newt label" for now.



# Cropping

We can convert image masks to a list of coordinates.
For example, with the newt mask:

```{python bbox-and-cropping}

def get_bbox(mask):
    mask_coords = np.stack(np.where(mask), axis = 1)
    bbox = {
        "min_x": np.min(mask_coords[:, 0]),
        "max_x": np.max(mask_coords[:, 0]),
        "min_y": np.min(mask_coords[:, 1]),
        "max_y": np.max(mask_coords[:, 1])
    }
    return(bbox)

def extend_bbox(bbox, pixels = 0):
    return {key: bound + (-1 if "min" in key else +1) * pixels \
            for key, bound in bbox.items()}


def crop(img, bx):
    if len(img.shape) == 3:
        return(img[bx["min_x"]:bx["max_x"], bx["min_y"]:bx["max_y"], :])
    if len(img.shape) == 2:
        return(img[bx["min_x"]:bx["max_x"], bx["min_y"]:bx["max_y"]])

def crop_mask(img, mask, return_crop_mask = False, extend_px = 0):
    bbox = extend_bbox(get_bbox(mask), extend_px)
    cropped_img = crop(img, bbox)

    if return_crop_mask:
        cropped_mask = crop(mask, bbox)
        return(cropped_img, cropped_mask)

    return cropped_img


```


Apply like this:

```{python crop-newt}
cropped_newt, cropped_mask = crop_mask(img, newt_mask, return_crop_mask = True, extend_px = 100)

newt_label_overlay = skicol.label2rgb(cropped_mask, image=cropped_newt, bg_label=0)

show(newt_label_overlay, title = "the cropped newt and its cropped mask")
plt.show()

```


With the channel tricks shown above, you can find one that only selects the yellow on the belly.
"Saturation" might be a good one?

```{python find-the-yellow-1}

newt_hsv = skicol.rgb2hsv(cropped_newt)

saturation = newt_hsv[:, :, 1]
# show(saturation); plt.show()
otsu = skifilt.threshold_otsu(saturation)

blurred_saturation = skifilt.gaussian(saturation, sigma = 4)
# show(blurred_saturation); plt.show()

plt.hist(blurred_saturation.ravel(), bins = 256)
plt.axvline(otsu)
plt.show()

```

As so often, Otsu threshold is probably too low.

Can we find our own threshold? Aye!
How about that histogram peak?

```{python relmax-threshold}
bins, edges = np.histogram(blurred_saturation.ravel(), bins = 256)
histogram_change = np.diff(bins)

# plt.step(edges[1:-1], histogram_change); plt.show()

downbins = sig.argrelmin(histogram_change)[0]
downbin_values = histogram_change[downbins]
right_ramp_bin = downbins[downbin_values < -5000][-1]

threshold = edges[right_ramp_bin] + 0.1

plt.hist(saturation.ravel(), bins = 256)
plt.axvline(threshold)
plt.show()


```


```{python find-the-yellow-2}
yellow_mask = skimorph.closing(
    np.logical_and(cropped_mask, blurred_saturation > threshold),
    skimorph.footprint_rectangle((5, 5))
)


newt_yellow_overlay = skicol.label2rgb(
    np.array(cropped_mask, dtype = int) +
    np.array(yellow_mask, dtype = int)
    , image=cropped_newt, bg_label=0)

show(newt_yellow_overlay); plt.show()

```

We got the yellow, we got the animal, let's do something with it!


# Rotation

The coordinates of the yellow ventral marking give a good general direction.
And the crop range.

But first, bring that direction to a default by rotating it.




