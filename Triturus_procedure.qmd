---
title: "Affine Newt Alignment"
subtitle: "Newt affine alignment for newt affine aligners."
format:
  html:
    toc: true
    html-math-method: katex
    code-fold: false
    embed-resources: true
knitr:
  opts_chunk:
    echo: true
---


# Procedure

- load image
- exposure normalization
- find features (blobs? yellow?)
- rotate rostro-caudal axis
- crop
- save


# pyenv

```{sh setup-virtual-environment}
#| eval: false
python -m venv newts
```

```{sh python-packages}
#| eval: false
source newts/bin/activate.fish
pip install --upgrade pip

# pip install --upgrade numpy scipy pandas matplotlib scikit-image pygobject
# pip freeze > requirements.txt
pip install --upgrade -r requirements.txt
```

# start python

```{sh start-python}
#| eval: false
source newts/bin/activate.fish
python

```

```{python libraries}
import numpy as np
import pandas as pd
import scipy.ndimage as ndi
import scipy.signal as sig
import skimage.io as skiio
import skimage.color as skicol
import skimage.filters as skifilt
import skimage.morphology as skimorph
import skimage.measure as skimeas
import skimage.segmentation as skiseg
import skimage.transform as skitrafo
import matplotlib as mpl
import matplotlib.pyplot as plt

# mpl.use("TkAgg")
mpl.use("gtk4agg") # does not matter much; defaults / TkAgg has trouble with my screen

```

# helper function

```{python show-function}

def show(img, ax = None, **kwargs):

    if ax is None:
        fig, ax = plt.subplots(1, 1)

    if len(img.shape) == 3:
        ax.imshow(img, origin = "upper")
    else:
        ax.imshow(img, origin = "upper", cmap = "gray")

    ax.set_axis_off()

    title = kwargs.get("title", None)
    if title is not None:
        ax.set_title(title)

```


# load image

## raw

```{python load-image}
image_file = "Triturus cristatus_female_4_2025-03-17_106_IMG_9269.JPG"
# image_file = "Triturus cristatus_male_4_2025-03-18_161_IMG_9396.JPG"
img = skiio.imread(image_file)

show(img, title = "raw photo")
plt.show()
```


## three channels

note:

- yellow gets best contrast on "red" channel
- on the red channel, the red marker text vanishes :)
- on the blue channel, the whole animal is black!
- petri dish is overexposed on all channels for this image


```{python split-channels}

fig, axarr = plt.subplots(1, 3)

for i in range(3):
    show(img[:,:,i], ax = axarr[i], title = "RGB"[i])

plt.show()
```


## hsv

There are other [color](https://scikit-image.org/docs/stable/api/skimage.color.html) 
spaces, [e.g.](https://en.wikipedia.org/wiki/HSL_and_HSV)
hsv (<https://stackoverflow.com/a/54632519>)

```{python convert-hsv}
img_hsv = skicol.rgb2hsv(img)

fig, axarr = plt.subplots(1, 3)

for i in range(3):
    show(img_hsv[:,:,i], ax = axarr[i], title = "HSV"[i])

plt.show()
```




## yuv

luma/chroma [yuv](https://en.wikipedia.org/wiki/Y%E2%80%B2UV)


```{python convert-yuv}
img_yuv = skicol.rgb2yuv(img)

fig, axarr = plt.subplots(1, 3)

for i in range(3):
    show(img_yuv[:,:,i], ax = axarr[i])

plt.show()
```

## inverting!

Remember that you can invert the channels!
When looking for good channels to separate the newt from the background, look for dark *and* light.

```{python invert-hsv}

show(1.-img_hsv[:,:,2], title = "inverted V")
plt.show()
```

## improvement

We can use the fact that the dish is the biggest object in the picture:

- find the dish
- fill "holes"
- blank region outside the dish
- then find the newt again.


```{python close-petri-dish}

mod = img_hsv[:,:,2] # the "V" channel

# plt.hist(mod.ravel(), bins = 256); plt.show()

# apply threshold
# thresh = (1.+skifilt.threshold_otsu(mod))/2 # good old otsu is just too low :)
thresh = 0.98 #np.quantile(mod, [0.8])[0] # Otsu is just a simple histogram method...

bw = skimorph.closing(mod > thresh,
                      skimorph.footprint_rectangle((5, 5)))
# plt.imshow(bw); plt.show()

# bw = skimorph.area_opening(bw, area_threshold = 8)

# label image regions
label_image = skimorph.label(bw)

biggest = np.argmax([region.area for region in skimeas.regionprops(label_image)])
# plt.imshow(label_image == int(1+biggest)); plt.show()
mask = skimorph.convex_hull_image(label_image == int(1+biggest))
# to make the background transparent, pass the value of `bg_label`,
# and leave `bg_color` as `None` and `kind` as `overlay`
image_label_overlay = skicol.label2rgb(mask, image=img, bg_label=0)


show(image_label_overlay, title = "petri dish mask")
plt.show()
```


```{python mask-image}
img_masked = img_hsv[:, :, 2]
img_masked[np.logical_not(mask)] = 1.

show(img_masked, title = "petri dish only")
plt.show()
```


# Image Differentials

## channel difference

First of all, we can subtract channels:

```{python rb-diff}
diff_img = img[:,:,0]-img[:,:,2]

show(diff_img, title = "red minus blue")
plt.show()
```

... but the problem is the background.
It might work better with some blur, though (not tested).


## edges

Then, there are spatial differentials:

```{python edge-sobel}
img_edge_sobel = skifilt.sobel(img)

fig, axarr = plt.subplots(1, 2)

show(img_edge_sobel, ax = axarr[0], title = "sobel edge filter")
show(img_edge_sobel[:, :, 2], ax = axarr[1], title = "blue channel of the sobel")

plt.show()
```


## not pursued: scaling, unsharp mask

the image could be scaled down
`image_rescaled = rescale(image, 0.25, anti_aliasing=False)`

Or better, apply some gaussian blur to smear out the non-newt contrast edges of the petri dish.




# Segmentation

... is just a name for the process of finding things in the image, 
separating "the relevant" from "the irrelevant" (no offence to petri dish manufacturers).

- <https://scikit-image.org/docs/stable/auto_examples/segmentation/plot_label.html#sphx-glr-auto-examples-segmentation-plot-label-py>


```{python labels}

# reminder: `img_masked` is the "V" in "HSV", masked so that only the petri dish is shown.
# We invert to find the newt as the "highlight" object.
mod = 1. - img_masked

# apply threshold
thresh = skifilt.threshold_otsu(mod) # good old otsu :)
bw = skimorph.closing(mod > thresh,
                      skimorph.footprint_rectangle((17, 17)))

# label image regions
label_image = skimorph.label(bw)
biggest = np.argmax([region.area for region in skimeas.regionprops(label_image)])
newt_mask = label_image == int(1+biggest)

image_label_overlay = skicol.label2rgb(newt_mask, image=img, bg_label=0)

show(image_label_overlay, title = "lonely newt")
plt.show()
```


... or immediately turn to the fancy stuff?
- <https://scikit-image.org/docs/stable/auto_examples/segmentation/plot_morphsnakes.html#sphx-glr-auto-examples-segmentation-plot-morphsnakes-py>

```{python snakes-for-newts}
#| eval: false

mod = 1. - img_masked # the inverted "V" channel

init_ls = skiseg.checkerboard_level_set(mod.shape, 8)

# fig, ax = plt.subplots(1, 1)
# ax.imshow(init_ls)
# ax.set_axis_off()
# ax.set_title("init")
# plt.show()


ls = skiseg.morphological_chan_vese(
    mod,
    num_iter=16,
    init_level_set=init_ls,
    smoothing=11
)


show(ls, title = "morphological snakes")
plt.show()
```

Oh, wow, that takes a bit, but the result is mildly promising.


Anyways, I will stick with the "simple newt label" for now.



# Cropping

We can convert image masks to a list of coordinates.
For example, with the newt mask:

```{python bbox-and-cropping}

def get_bbox(mask):
    mask_coords = np.stack(np.where(mask), axis = 1)
    bbox = {
        "min_x": np.min(mask_coords[:, 0]),
        "max_x": np.max(mask_coords[:, 0]),
        "min_y": np.min(mask_coords[:, 1]),
        "max_y": np.max(mask_coords[:, 1])
    }
    return(bbox)

def extend_bbox(bbox, pixels = 0):
    return {key: bound + (-1 if "min" in key else +1) * pixels \
            for key, bound in bbox.items()}


def crop(img, bx):
    if len(img.shape) == 3:
        return(img[bx["min_x"]:bx["max_x"], bx["min_y"]:bx["max_y"], :])
    if len(img.shape) == 2:
        return(img[bx["min_x"]:bx["max_x"], bx["min_y"]:bx["max_y"]])

def crop_mask(img, mask, return_crop_mask = False, extend_px = 0):
    bbox = extend_bbox(get_bbox(mask), extend_px)
    cropped_img = crop(img, bbox)

    if return_crop_mask:
        cropped_mask = crop(mask, bbox)
        return(cropped_img, cropped_mask)

    return cropped_img


```


Apply like this:

```{python crop-newt}
cropped_newt, cropped_mask = crop_mask(img, newt_mask, return_crop_mask = True, extend_px = 100)

newt_label_overlay = skicol.label2rgb(cropped_mask, image=cropped_newt, bg_label=0)

show(newt_label_overlay, title = "the cropped newt and its cropped mask")
plt.show()

```


With the channel tricks shown above, you can find one that only selects the yellow on the belly.
"Saturation" might be a good one?

```{python find-the-yellow-1}

newt_hsv = skicol.rgb2hsv(cropped_newt)

saturation = newt_hsv[:, :, 1]
# show(saturation); plt.show()
otsu = skifilt.threshold_otsu(saturation)

blurred_saturation = skifilt.gaussian(saturation, sigma = 4)
# show(blurred_saturation); plt.show()

plt.hist(blurred_saturation.ravel(), bins = 256)
plt.axvline(otsu)
plt.show()

```

As so often, Otsu threshold is probably too low.

Can we find our own threshold? Aye!
How about that histogram peak?

```{python relmax-threshold}
bins, edges = np.histogram(blurred_saturation.ravel(), bins = 256)
histogram_change = np.diff(bins)

# plt.step(edges[1:-1], histogram_change); plt.show()

downbins = sig.argrelmin(histogram_change)[0]
downbin_values = histogram_change[downbins]
right_ramp_bin = downbins[downbin_values < -5000][-1]

threshold = edges[right_ramp_bin] + 0.1

plt.hist(saturation.ravel(), bins = 256)
plt.axvline(threshold)
plt.show()


```


```{python find-the-yellow-2}
yellow_mask = skimorph.closing(
    np.logical_and(cropped_mask, blurred_saturation > threshold),
    skimorph.footprint_rectangle((5, 5))
)


newt_yellow_overlay = skicol.label2rgb(
    np.array(cropped_mask, dtype = int) +
    np.array(yellow_mask, dtype = int)
    , image=cropped_newt, bg_label=0)

show(newt_yellow_overlay); plt.show()

```

We got the yellow, we got the animal, let's do something with it!


# Rotation

The coordinates of the yellow ventral marking give a good general direction.
And the crop range.

But first, bring that direction to a default by rotating it.
Before, get the direction. PCA can help. `skimage` has all the tools.


```{python regionprops}

props = skimeas.regionprops(
    np.array(yellow_mask, dtype = int),
    intensity_image = cropped_newt
)[0]
#    properties=('area', 'area_bbox', 'area_convex', 'area_filled', 'axis_major_length', 'axis_minor_length', 'bbox', 'centroid', 'centroid_local', 'centroid_weighted', 'centroid_weighted_local', 'coords', 'coords_scaled', 'eccentricity', 'equivalent_diameter_area', 'euler_number', 'extent', 'feret_diameter_max', 'image', 'image_convex', 'image_filled', 'image_intensity', 'inertia_tensor', 'inertia_tensor_eigvals', 'intensity_max', 'intensity_mean', 'intensity_min', 'intensity_std', 'label', 'moments', 'moments_central', 'moments_hu', 'moments_normalized', 'moments_weighted', 'moments_weighted_central', 'moments_weighted_hu', 'moments_weighted_normalized', 'num_pixels', 'orientation', 'perimeter', 'perimeter_crofton', 'slice', 'solidity'),

# print(yellow_mask.shape)
# print(props["centroid"])
# print(props["inertia_tensor"])
# print(props["orientation"])
# print(props["bbox"])

# just in case: convert a prop bbox to dict bbox
convert_prop_bbox = lambda bx: \
    {"min_x": bx[0], "min_y": bx[1], "max_x": bx[2], "max_y": bx[3]}


```


```{python rotate-newt}

get_aspect = lambda b: (b[2]-b[0])/(b[3]-b[1])
is_vertical = lambda props: get_aspect(props["bbox"]) > 1.0
com_vertical = lambda props: props["centroid"][0] / (props["bbox"][2]-props["bbox"][0])
com_horizontal = lambda props: props["centroid"][1] / (props["bbox"][3]-props["bbox"][1])
# aspect = get_aspect(props["bbox"])
def get_angle(props):
    angle = props["orientation"]*180/np.pi
    if is_vertical(props):
        # (A) north-south orientation
        angle += 90

        # is the head down or up?
        head_down = com_vertical(props) > 0.5
        if head_down:
            angle += 180
    else:
        # (B) ost-west orientation
        # check head right
        head_left = com_horizontal(props) < 0.5
        if head_left:
            angle += 180

    return(angle)

# skimage returns orientation in radians, but rotates with degrees :/
rotate_orientation = lambda img, props: \
    skitrafo.rotate(img, -get_angle(props), resize = True, center = props["centroid"])
    

rotated_newt = rotate_orientation(cropped_newt, props)

# fig, axarr = plt.subplots(1, 2)
# show(cropped_newt, axarr[0])
# show(rotated_newt, axarr[1])
# plt.show()

rotated_mask = rotate_orientation(cropped_mask, props)
rotated_ymask = rotate_orientation(yellow_mask, props)


rotated_overlay = skicol.label2rgb(
    np.array(rotated_mask, dtype = int) +
    np.array(rotated_ymask, dtype = int)
    , image = rotated_newt, bg_label=0)

show(rotated_overlay); plt.show()

```


```{python crop-rotated}


standard_newt = crop_mask(rotated_newt, rotated_ymask, return_crop_mask = False, extend_px = 0)

show(standard_newt)
plt.show()

```


You can go further by cropping the limbs even more.
but that would definitely not be nice, eh!


If the tail is an issue: use the centroid and the bbox.

```{r}

rprops = skimeas.regionprops(np.array(rotated_ymask, dtype = int))[0]

centroid = rprops["centroid"] # area centroid without intensity weighting
bbox = np.array(rprops["bbox"])
dx = min(abs(bbox[[0,2]]-centroid[0]))
dy = min(abs(bbox[[1,3]]-centroid[1]))

body_box = {
        "min_x": int(centroid[0]-dx),
        "max_x": int(centroid[0]+dx),
        "min_y": int(centroid[1]-dy),
        "max_y": int(centroid[1]+dy)
    }

final_crop = crop(rotated_newt, body_box)

show(final_crop); plt.show()
```


# Affine Transform

- <https://scikit-image.org/docs/stable/api/skimage.transform.html#skimage.transform.AffineTransform>
